# 图

## 图的存储方式

1. 邻接表
2. 邻接矩阵

如何表达图？如何生成图  

1. 邻接表法
![邻接表法](01.jpeg)
![邻接表法+边的权值](02.jpeg)
![邻接矩阵](03.jpeg)
特殊
![图的另一种表达方式](04.jpeg)

```java
public class Node {
    public int value;  // 値
    public int in; // 入度
    public int out; // 出度
    public ArrayList<Node> nexts; // 从该点发散出去的点
    public ArrayList<Eage> edges; // 从该点发散出去的边

    public Node(int value) {
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<>();
    }
}

// 有向边
// 无向边(有向边*2)
public class Edge {
    public int weight; // 权值
    public Node form;  // 
    public Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}

public class Graph {
    public HashMap<Integer, Node> nodes;
    public HashSet<Edge> edges;

    public Graph() {
        nodes = new HashMap();
        edges = new HashSet();
    }
}

// N*3的矩阵
// [weight, from节点上边的值，to节点上面的值]
public static Graph createGraph(Integer[][] matrix) {
    Graph graph = new Graph();

    for (int i = 0; i < martix.length; i++) { // matrix[0][0] matrix[0][1] matrix[0][2]
        Integer from = matrix[i][0];
        Integer to = matrix[i][1];
        Integer weight = matrix[i][2];

        if (!graph.nodes.containsKey(from)) {
            graph.nodes.put(from, new Node(from));
        }
        if (!graph.nodes.containsKey(to)) {
            graph.nodes.put(to, new Node(to));
        }

        Node fromNode = graph.nodes.get(from);
        Node toNode = graph.nodes.get(to);

        Edge newEdge = new Edge(weight, fromNode, toNode);
        fromNode.nexts.add(toNode);
        fromNode.out++;
        toNode.in++;
        fromNode.edges.add(newEdge);

        graph.edges.add(newEdge);
    }

    return graph;
}
```