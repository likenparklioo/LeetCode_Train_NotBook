# 认识O(NlogN)的排序

## 剖析递归行为和递归行为时间复杂度的计算

---

## 用递归方法找一个数组中的最大值，系统上到底是怎么做到的

---

### 数组中点的求法

```java
一般中点的求法为
mid = (L + R) / 2
// L为数组左边范围的位置 R为右边范围的位置
这样做有一个问题，就是如果数组长度特别的大的时候L+R可能会溢出 mid可能算出来负数
 
所以采用
mid = L + (R - L) / 2
的方法可以避免上诉情况

更简单的写法为
mid = L + (R - L) >> 1
右移一位相当于除2

public class Code_GetMax {
    public static int getMax(int[] arr) {
        return process(arr, 0, arr.length() - 1);
    }

    // arr[L..R]范围上求最大值N
    public static int process(int[] arr, int L, int R) {
        // base case arr[L..R]范围上只有一个数，则直接返回
        if (L == R) {
            return arr[L];
        }

        // 中点
        int mid = L + (R - L) >> 1;

        int leftMax = process(arr, L, mid);
        int rightMax = process(arr, mid + 1, R);

        return Math.max(leftMax, rightMax);
    }
}

[9, 4, 2, 3, 6, 7]
 0  1  2  3  4  5

                                p(0, 5)
                               /       \
                        P(0, 2)          P(3, 5)
                       /       \        /       \
                P(0, 1)   P(2, 2)       P(3, 4)  P(5, 5)
               /      \                 /      \
        P(0, 0)  P(1, 1)               P(3, 3)  P(4, 4)

递归的过程可以看做是一个多叉树 从压栈到汇总信息弹出
每次计算遇到悬而未决的东西就会先压到栈里去
等计算完结果之后在从栈里弹出
栈空间为整棵树的高度
```

上述问题的master公式为

$
T(N) = 2 * T (\frac{N}{2}) + O(1)\\
a=2 \:\:\:\:\:\: b=2  \:\:\:\:\:\: d=0
$

## master公式的使用

$
T(N) = a * T (\frac{N}{b}) + O(N^d)\\
T(N)为母问题的数据规模\\
T (\frac{N}{b})为子问题的数据规模，每个子问题的数据规模是等量的\\
a为子问题被调用的次数\\
 O(N^d)为除了子问题之外，剩下的过程的时间复杂度
$

统一符合master公式形式的递归，它的时间复杂度可直接求解
※只要是满足子问题等规模的递归
当a,b,d确定后可以通过下面的式子直接求解时间复杂度

1. $\log_ba > d$ -> 复杂度为$O(N^{log_ba})$
2. $\log_ba = d$ -> 复杂度为$O(N^{d} * logN)$
3. $\log_ba < d$ -> 复杂度为$O(N^{d})$

---

## 归并排序(merge sort)

---

1. 整体就是一个简单递归，左边排好序，右边排好序，让其整体有序
2. 让整体有序的过程里用了外排序方法
3. 利用master公式来求解时间复杂度
4. 归并排序的实质

时间复杂度$O(N*logN)$,额外空间复杂度$O(N)$

```java
            [3, 2, 1, 5, 6, 2]
            [L......M.......R]
    先让左侧排好序            再让右侧排好序
    [1, 2, 3]                [2, 5, 6]
     ^                        ^
  >>[1]
        ^                     ^
  >>[1, 2]
           ^                  ^
  >>[1, 2, 2]
           ^                     ^
  >>[1, 2, 2, 3]
  >>[1, 2, 2, 3, 5, 6]

public class Code_MergeSort {
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length() < 2) {
            return;
        }

        process(arr, 0, arr.length() - 1);
    }

    public static void process(int[] arr, int L, int R) {
        if (L == R) {
            return;
        }

        int mid = L + (R - L) / 2 >> 1;
        process(arr, L, mid); // 子问题规模 N/2
        process(arr, R, mid); // 子问题规模 N/2
        merge(arr, L, mid, R);
    }

    // merge时间复杂度为O(N)
    // L[...]   R[...]
    // ----->   ----->
    // 在merge过程中因为每次只走一个所以在走完后时间复杂度为O(N)
    public static void merge(int[] arr, int L, int mid, int R) {
        int[] help = new int[R - L + 1];

        int i = 0;
        int p1 = L;
        int p2 = mid + 1;

        while(p1 <= mid && p2 <= R) {
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }

        while(p1 <= mid) {
            help[i++] = arr[p1++];
        }

        while(p2 <= R) {
            help[i++] = arr[p2++];
        }

        for (i = 0; i < help.length(); i++) {
            arr[L + i] = help[i];
        }
    }
}
```

## MergeSort的master公式

$
T(N) = 2 *T (\frac{N}{2}) + O(N)\\
a=2,b=2,d=1\\
log_ab=d >> O(N* logN)
$

## MergeSort的实质

选择排序，冒泡排序，插入排序在执行的时候浪费的大量的比较行为。
0 ~ N在比较之后只能确定一个数。
而MergeSort则保证了在最小的左右两边单位处有序，然后通过merge成一个整体有序的部分，然后去跟下一个更大范围的部分去merge
然后继续向下传递，在执行过程中比较的过程并没有被浪费而知得到了保留。
所以归并排序可以做到$O(N* logN)$的时间复杂度。

## 归并排序的扩展

小和问题和逆序对问题

- 小何问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和  
例子:[1,3,4,2,5]  
1左边比1小的数没有；  
3左边比3小的数，1；  
4左边比4小的数，1、3；  
2左边比2小的数，1；
5左边比5小的数，1、3、4、2；  
所以小和为 1+1+3+1+1+3+4+2=16

暴力求解的时间复杂度O(N^2)

```java
    思路转换
    [...] i 求i位置左边比i小的数的小和等同于在一个数组中

    [1,3,4,2,5]
     ^         求右边有多少个数比1大，因为求i位置左边比i小的数的时候1位置的数都会被累加一遍，
               则右边有多少个数比1大则关于1就有多少个小和

    [1,3,4,2,5]
     ^          1 * 4
       ^        3 * 2
         ^      4 * 1
           ^    2 * 1
             ^  5 * 0
    
    转换思路后这个问题可以通过归并排序来求解

    merge流程
    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]

    L            R                 L        R
    [1,3]        [4]               [2]      [5]
    
    L       R
    [1]     [3]
     ^       ^

    >> [1, 3] >> 关于1位置在右侧上找到的1个数比1大 >> 1 * 1


    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]

    L            R                 L        R
    [1,3]        [4]               [2]      [5]
     ^            ^

    >> [1] >> 关于1位置在右侧上找到的1个数比1大 >> 1 * 1

    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]

    L            R                 L        R
    [1,3]        [4]               [2]      [5]
       ^          ^

    >> [1, 3] >> 关于3位置在右侧上找到的1个数比1大 >> 3 * 1

    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]

    L            R                 L        R
    [1,3]        [4]               [2]      [5]
                  ^

    >> 左侧越界然后将4拷贝下来 >> [1, 3, 4]

    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]

                                   L        R
                                   [2]      [5]
                                    ^        ^                  

    >> [2] >> 右侧有一个数比2大 >> 2 * 1    ※右侧小的时候是不产生小和的，只有在左侧小的时候才产生小和

    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]

                                   L        R
                                   [2]      [5]
                                             ^                  

    >> [2，5] 

    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]
     ^                              ^

    >> [1]  >> 在右侧有两个数比1大，可以通过下表计算直接算出 >> 1 * 2

    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]
       ^                            ^

    >> [1,2]  >> 2比3小不产生小和

    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]
       ^                              ^

    >> [1,2,3]  >> 在右侧有1个数比3大，可以通过下表计算直接算出 >> 3 * 1

    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]
         ^                            ^

    >> [1,2,3,4]  >> 在右侧有1个数比4大，可以通过下表计算直接算出 >> 4 * 1

    [1,3,4,2,5]

    L                              R
    [1,3,4]                        [2,5]
                                      ^

    >> 左边下标越界拷贝5 >> [1,2,3,4,5]

    对于1来说，不遗漏的不重算的找到了所以比1大的数的个数


    问题:排序的动作是否可以省略，答案是不能省略
    因为在计算关于左边的某个位置，右边有多少个比当前位置大的数的时候需要通过下标计算来算出，所以需要左右两边都有序，所以排序的过程是不可以省略的，
    如果省略就失去了归并排序的意义，还不如直接暴力求解好


    与经典的merge的不同的地方
    [111122335]   [111122667]
     ^             ^
    [111122335]   [111122667]
     ^                 ^
    当左组的数与右组的数相等的时候一定要先拷贝右组的数而且不产生小和
    如果先拷贝左组的数，则不能一下子知道右组数里有多少个数比1大

    public class Code_SmallSum {
        public static int smallSum(int[] arr) {
            if (arr == null || arr.length() < 2) {
                return 0;
            }

            process(arr, 0, arr.length() - 1);
        }

        // arr[L ... R]即要排好序也要求小和
        public static int process(int[] arr, int L, int R) {
            if (L == R) {
                return 0;
            }

            int mid = L + (R - L) / 2 >> 1;
            return process(arr, L, mid) +
                   process(arr, R, mid) +
                   merge(arr, L, mid, R);
        }

        public static int merge(int[] arr, int L, int mid, int R) {
            int[] help = new int[R - L + 1];

            int i = 0;
            int p1 = L;
            int p2 = mid + 1;
            int res = 0;

            while(p1 <= mid && p2 <= R) {
                res += arr[p1] < arr[p2] ? arr[p1] * (r - p2 + 1) : 0;
                help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++]; // 只有在左边严格小于右边的时候，才拷贝左边，否则(>=)先拷贝右边的数
            }

            while(p1 <= mid) {
                help[i++] = arr[p1++];
            }

            while(p2 <= R) {
                help[i++] = arr[p2++];
            }

            for (i = 0; i < help.length(); i++) {
                arr[L + i] = help[i];
            }

            return res;
        }
    }
```

- 逆序对问题
    在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对， 请打印所有逆序对。  
    这种问题也是通过归并排序的方法来求解的。

## 荷兰国旗问题

- 问题1
  给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1),时间复杂度O(N)。

  ```java
  [3,5,6,7,4,3,5,8]     num=5

  __________
   <= area | [3,5,6,7,4,3,5,8] 
  ----------
              ^

  1)[i] <= num  [i]和<=区的下一个数交换，<=区右扩，i++
  _______________
   <= area   [3,|5,6,7,4,3,5,8] 
  ---------------
                 ^
  _________________
   <= area   [3,5,|6,7,4,3,5,8] 
  -----------------
                   ^

  2)[i] > num，i++
  _________________
   <= area   [3,5,|6,7,4,3,5,8] 
  -----------------
                   ^
  _________________
   <= area   [3,5,|6,7,4,3,5,8] 
  -----------------
                     ^


  _________________
   <= area   [3,5,|6,7,4,3,5,8] 
  -----------------
                       ^
  _________________
   <= area   [3,5,|4,7,6,3,5,8] 
  -----------------
                       ^
  ___________________
   <= area   [3,5,4,|7,6,3,5,8] 
  -------------------
                         ^
  .
  .
  .

  ```

- 问题2（荷兰国旗问题）
  给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1),时间复杂度O(N)。

  ```java
  1)[i]<num,[i]和小于区域下一个做交换，小于区域右扩,i++
  2)[i]=num,i++
  3)[i]>num,[i]和大于区域前一个做交换，大于区域左扩,i不变

        [3,5,6,3,4,5,2,6,9,0]         num=5
  ______                     ______
    <                           >
         i

        [3,5,6,3,4,5,2,6,9,0]
  ________                   ______
    <                           >
           i
  [i]和小于区域的下一个做交换 > 3跟3交换 > i++ > 小于区域右扩 

        [3,5,6,3,4,5,2,6,9,0]
  ________                   ______
    <                           >
             i
  [i]=5,i++

        [3,5,0,3,4,5,2,6,9,6]
  ________                 ________
    <                           >
             i
  [i]>5,[i]和大于区域的前一个做交换，6跟0交换,大于区域左扩，i不变

        [3,0,5,3,4,5,2,6,9,6]
  __________               ________
    <                           >
               i
  [i]<5,[i]和小于区域的下一个做交换, 5跟0交换 > i++ > 小于区域右扩 
  .
  .
  .
  ```

## 快排

- 快排1.0
  
    ```java
    [           ...            ,num]
                                ^
    1.以数组的最后一个数为基准，将数组分段
    [    <=num   |    >num     ,num]

    2.将num与,>num区域的第一个数做交换
    [    <=num   |num|    >num     ]
                    ^
    这样可以保证num是<=num范围的最后一个数
    3.然后通过递归将左侧（<=num）部分和右侧（>num）部分进行同样的递归操作
    [    <=num   |num|    >num     ]
                ^                 ^
     ```

- 快排2.0
  
    ```java
    [                      ...                   ,num]
    1.以数组的最后一个数为基准，将数组分段
    [    <num          | ==num |        >num     ,num]
    2.将num与,>num区域的第一个数做交换
    [    <num          | ==num | num |      >num     ] 
    3.然后通过递归将左侧（<=num）部分和右侧（>num）部分进行同样的递归操作
    [    <num          | ==num | num |      >num     ]
                    ^                             ^
    这样一次可以搞定一批相等数，所以快排2.0比1.0稍微快一些
    ```

- 快排1.0和2.0的时间复杂度都为$O(N^2)$

    ```java
    最差数据状况
    [1,2,3,4,5,6,7,8,9]
                     ^
                   ^
                 ^
    每一次划分的过程(partition)只能搞定一个数,所以时间复杂度为O(N^2)
    ```

- 快排3.0
  
  导致快排最差情况的原因只有一个，就是划分值打的很偏，产生差情况

  ```java
  最理想的划分值情况为刚好打到中间
  [   ...    P   ...   ]
  ```
  
  根据master公式$T(N) = 2T(\frac{N}{2}) + O(N)$的时间复杂度为$O(N*logN)$  
  如果划分值打的很偏则会导致快排的时间复杂度逐渐退化成$O(N^2)$

  ```java
  差情况
  [ . P      ......    ]
  最差情况 P直接打到最左边或最右边
  [P      ......       ]
  ```

  快排3.0的解决方法
  
  ```java
  [L      ......      R]
  在L到R范围内等概率随机挑选一个数，与最后一个数做交换，然后再进行快排
  这样取到好情况和差情况就变成了一个概率事件

  把所有的情况求出来做概率累加，算出概算法在数学上的长期期望是 O(N*logN)的算法


  public class Code_QuickSort {

      public static void quickSort(int[] arr) {
          if (arr == null || arr.length() < 2) {
              return;
          }
          quickSort(arr, 0, arr.length() - 1);
      }

      // arr[l..r]排好序
      public static void quickSort(int[] arr, int L, int R) {
          if (L < R) {
                swap(arr, L + (int) (Math.random() + (R - L + 1)), R);
                // 返回值为 [L   | == p |    R] 中==p范围的左边界和有边界
                //              ^      ^
                int[] p = partition(arr, L, R);
                quickSort(arr, L, p[0] - 1); // < 区
                quickSort(arr, L, p[1] + 1); // > 区
          }
      }

      // 这是一个处理arr[l..r]的函数
      // 默认arr[r]做划分, arr[r] -> p       <p     ==p     >p
      // 返回等于区域(左边界，右边界)，所以返回一个长度为2的数组res, res[0], res[1]
      public static int[] partition(int[] arr, int L, int R) {
          int less = L - 1; // <区的右边界
          int more = R // >区的左边界

          while (L < mone) { // L表示当前数的位置     arr[R]为划分值
              if (arr[L] < arr[R]) {  // 当前数 < 划分值
                  swap(arr, ++less, L++)
              } else if (arr[L] > arr[R]) { // 当前数 > 划分值
                  swap(arr, --more, L)
              } else {
                  L++;
              }
          }

          swap(arr, more, R);
          return new int[] {less + 1, more};
      }
  }

  快排的空间复杂度O(logN)
    也是求概率累加
    
    最差情况是O(N)
    最差数据状况的递归层数N层
    [1, 2, 3, 4, 5, 6]
                    ^
    [1, 2, 3, 4, 5]
                 ^
    [1, 2, 3, 4]
              ^
    [1, 2, 3]
           ^
    [1, 2]
        ^
    [1]
     ^
    
    好情况则是近似一个完全二叉树或满二叉树的展开
    [       ...          P         ...        ]
                         ^
    [   ...   P   ...   ]
              ^
    [   P   ]   [   P   ]
        ^           ^    
    [L ] [R ]   [L ] [R ]
    ---------

    左边在计算完成之后会释放掉记录中点的空间然后再去计算右边
    所以在好情况下整体的空间复杂度为logN水平

    就算不用递归写，改成手动迭代的方法来实现的话，这个用来记录中点位置的空间是无论如何也省不掉的
    因为从子问题回到母问题的时候，只有知道当前中点位置在哪，才能进行下一步递归操作，并且中点位置
    会根据当前数据状况的不同而发生变化，并不是不固定的
  ```
