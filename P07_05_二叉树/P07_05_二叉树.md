# 二叉树

## 题目1 二叉树节点结构

```java
class Node<V> {
    V value;
    Node left;
    Node right;
}
```

用递归和非递归两种方式实现二叉树的先序，中序，后序遍历

如何直观的打印一颗二叉树

如何完成二叉树的宽度优先遍历(常见题目: 求一颗二叉树的宽度)

递归方法完成二叉树的遍历每一个节点都能回到3次

```java
public static void f(Node head) {
    if (head == null) {
        return;
    }

    f(head.left);
    f(head.right);
}
```

## 用递归和非递归两种方式实现二叉树的先序，中序，后序遍历

---

![二叉树的递归序](01.jpeg)

先序 先打印头节点  再打印左子树上所有的节点  在打印右子树上所有的节点  
先序遍历是由递归序加工而来

![二叉树的先序遍历](02.jpeg)

中序 左 头 右  
由递归序加工，在第二次回到自己的时候打印  
后序 左 右 头  
由递归序加工，在第三次回到自己的时候打印  

![二叉树的中后序遍历](03.jpeg)

```java
public static void preOrderRecur(Node head) {
    if (head == null) {
        return;
    }

    System.out.print(head.value + " ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}

public static void inOrderRecur(Node head) {
    if (head == null) {
        return;
    }

    inOrderRecur(head.left);
    System.out.print(head.value + " ");
    inOrderRecur(head.right);
}

public static void posOrderRecur(Node head) {
    if (head == null) {
        return;
    }

    posOrderRecur(head.left);
    posOrderRecur(head.right);
    System.out.print(head.value + " ");
}

public static void main(String[] args) {
    Node head = new Node(5);
    head.left = new Node(3);
    head.right = new Node(8);
    head.left.left = new Node(2);
    head.left.right = new Node(4);
    head.left.left = new Node(1);
    head.right.left = new Node(7);
    head.right.left.left = new Node(6);
    head.right.right = new Node(10);
    head.right.right.left = new Node(9);
    head.right.right.right = new Node(11);

    // recursive
    System.out.println("===============recursive================");
    System.out.println("pre-order");
    preOrderRecur(head);
    System.out.println();
    System.out.println("in-order");
    inOrderRecur(head);
    System.out.println();
    System.out.println("pos-order");
    posOrderRecur(head);
    System.out.println();
}
```

任何递归都可以改成非递归  
非递归先序遍历  

先将头结点压入栈中
每次

1. 从栈中弹出一个节点cur
2. 打印处理cur
3. 先右在左(如果有)
4. 周而复始

![非递归先序遍历](04.jpeg)

```java
public static void preOrderUnRecur(Node) {
    System.out.print("pre-order");
    if (head != null) {
        Stack<Node> stack = new Stack<Node>();
        stack.add(head);
        while(!stack.isEmpty()) {
            head = stack.pop();
            System.out.print(head.value + " ");
            if (head.right != null) {
                stack.push(head.right);
            }
            if (head.left != null) {
                stack.push(head.left);
            }
        }
    }
    System.out.println();
}
```

非递归后序遍历
先将头结点压入栈中
每次

1. 从栈中弹出一个节点cur
2. cur放入收集栈
3. 先左再右(如果有)
4. 周而复始

因为每次放入收集栈的顺序为 头 右 左  
然后再从收集栈中弹出的顺序为 左 右 头 从而实现后序遍历

![非递归后序遍历](05.jpeg)

```java
public static void posOrderUnRecur1(Node head) {
    System.out.print("pos-order: ");
    if (head != null) {
        Stack<Node> s1 = new Stack<Node>();
        Stack<Node> s2 = new Stack<Node>();
        s1.push(head);
        while (s1 != null) {
            head = s1.pop();
            s2.push(head);
            if (head.left != null) {
                s1.push(head.left);
            }
            if (head.right != null) {
                s2.push(head.right);
            }
        }
        while (!s2.isEmpty()) {
            System.out.print(s2.pop().value + " ");
        }
    }
    System.out.println();
}
```

非递归中序遍历  

中: 左 右 头

1. 每颗子树，整颗数左边界进栈
2. 依次弹出的过程中，打印
3. 对弹出节点的右树做周而复始的操作

![非递归中序遍历](06.jpeg)

```java
public static void inOrderUnRecur(Node head) {
    System.out.print("in-order: ");
    if (head != null) {
        Stack<Node> stack = new Stack<Node>();
        while (!stack.isEmpty() || head != null) {
            if (head != null) {
                stack.push(head);
                head = head.left;
            } else {
                head = stack.pop();
                System.out.print(head.value + " ");
                head = head.right;
            }
        }
    }
    System.out.println();
}
```

实质  
二叉树可以被左树分解  
![二叉树左树分解1](07.jpeg)
![二叉树左树分解2](08.jpeg)

## 如何直观的打印一颗二叉树

领取视频资料加小助理WX：msb6989

## 如何完成二叉树的宽度优先遍历(常见题目: 求一颗二叉树的宽度)

二叉树的先序遍历就是二叉树的深度优先遍历

![二叉树宽度优先遍历](09.jpeg)

1. 先将头结点放入队列
2. 弹出节点，然后将该节点的左右孩子节点依次放入队列
3. 周而复始

```java
public static void w(Node head) {
    if (head == null) {
        return;
    }

    Queue<Node> queue = new LinkedList<>();
    queue.add(head);
    while (!queue.isEmpty()) {
        Node cur = queue.poll();
        System.out.println(cur.value);
        if (cur.left != null) {
            queue.add(cur.left);
        }
        if (cur.right != null) {
            queue.add(cur.right);
        }
    }
}
```
